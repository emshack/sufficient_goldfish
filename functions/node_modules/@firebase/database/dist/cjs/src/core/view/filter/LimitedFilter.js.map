{"version":3,"sources":["../src/core/view/filter/LimitedFilter.ts"],"names":[],"mappings":"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","file":"LimitedFilter.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RangedFilter } from './RangedFilter';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { Node, NamedNode } from '../../snap/Node';\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { IndexedFilter } from './IndexedFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class LimitedFilter implements NodeFilter {\n  /**\n   * @const\n   * @type {RangedFilter}\n   * @private\n   */\n  private readonly rangedFilter_: RangedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private readonly index_: Index;\n\n  /**\n   * @const\n   * @type {number}\n   * @private\n   */\n  private readonly limit_: number;\n\n  /**\n   * @const\n   * @type {boolean}\n   * @private\n   */\n  private readonly reverse_: boolean;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.rangedFilter_ = new RangedFilter(params);\n    this.index_ = params.getIndex();\n    this.limit_ = params.getLimit();\n    this.reverse_ = !params.isViewFromLeft();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    if (snap.getImmediateChild(key).equals(newChild)) {\n      // No change\n      return snap;\n    } else if (snap.numChildren() < this.limit_) {\n      return this.rangedFilter_\n        .getIndexedFilter()\n        .updateChild(\n          snap,\n          key,\n          newChild,\n          affectedPath,\n          source,\n          optChangeAccumulator\n        );\n    } else {\n      return this.fullLimitUpdateChild_(\n        snap,\n        key,\n        newChild,\n        source,\n        optChangeAccumulator\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    let filtered;\n    if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n    } else {\n      if (\n        this.limit_ * 2 < newSnap.numChildren() &&\n        newSnap.isIndexed(this.index_)\n      ) {\n        // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        // anchor to the startPost, endPost, or last element as appropriate\n        let iterator;\n        if (this.reverse_) {\n          iterator = (newSnap as ChildrenNode).getReverseIteratorFrom(\n            this.rangedFilter_.getEndPost(),\n            this.index_\n          );\n        } else {\n          iterator = (newSnap as ChildrenNode).getIteratorFrom(\n            this.rangedFilter_.getStartPost(),\n            this.index_\n          );\n        }\n        let count = 0;\n        while (iterator.hasNext() && count < this.limit_) {\n          const next = iterator.getNext();\n          let inRange;\n          if (this.reverse_) {\n            inRange =\n              this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n          } else {\n            inRange =\n              this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n          }\n          if (inRange) {\n            filtered = filtered.updateImmediateChild(next.name, next.node);\n            count++;\n          } else {\n            // if we have reached the end post, we cannot keep adding elemments\n            break;\n          }\n        }\n      } else {\n        // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n        filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(\n          ChildrenNode.EMPTY_NODE\n        ) as ChildrenNode;\n        let startPost;\n        let endPost;\n        let cmp;\n        let iterator;\n        if (this.reverse_) {\n          iterator = filtered.getReverseIterator(this.index_);\n          startPost = this.rangedFilter_.getEndPost();\n          endPost = this.rangedFilter_.getStartPost();\n          const indexCompare = this.index_.getCompare();\n          cmp = (a: NamedNode, b: NamedNode) => indexCompare(b, a);\n        } else {\n          iterator = filtered.getIterator(this.index_);\n          startPost = this.rangedFilter_.getStartPost();\n          endPost = this.rangedFilter_.getEndPost();\n          cmp = this.index_.getCompare();\n        }\n\n        let count = 0;\n        let foundStartPost = false;\n        while (iterator.hasNext()) {\n          let next = iterator.getNext();\n          if (!foundStartPost && cmp(startPost, next) <= 0) {\n            // start adding\n            foundStartPost = true;\n          }\n          let inRange =\n            foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n          if (inRange) {\n            count++;\n          } else {\n            filtered = filtered.updateImmediateChild(\n              next.name,\n              ChildrenNode.EMPTY_NODE\n            );\n          }\n        }\n      }\n    }\n    return this.rangedFilter_\n      .getIndexedFilter()\n      .updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.rangedFilter_.getIndexedFilter();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!Node} snap\n   * @param {string} childKey\n   * @param {!Node} childSnap\n   * @param {!CompleteChildSource} source\n   * @param {?ChildChangeAccumulator} changeAccumulator\n   * @return {!Node}\n   * @private\n   */\n  private fullLimitUpdateChild_(\n    snap: Node,\n    childKey: string,\n    childSnap: Node,\n    source: CompleteChildSource,\n    changeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    // TODO: rename all cache stuff etc to general snap terminology\n    let cmp;\n    if (this.reverse_) {\n      const indexCmp = this.index_.getCompare();\n      cmp = (a: NamedNode, b: NamedNode) => indexCmp(b, a);\n    } else {\n      cmp = this.index_.getCompare();\n    }\n    const oldEventCache = snap as ChildrenNode;\n    assert(oldEventCache.numChildren() == this.limit_, '');\n    const newChildNamedNode = new NamedNode(childKey, childSnap);\n    const windowBoundary = this.reverse_\n      ? oldEventCache.getFirstChild(this.index_)\n      : (oldEventCache.getLastChild(this.index_) as NamedNode);\n    const inRange = this.rangedFilter_.matches(newChildNamedNode);\n    if (oldEventCache.hasChild(childKey)) {\n      const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n      let nextChild = source.getChildAfterChild(\n        this.index_,\n        windowBoundary,\n        this.reverse_\n      );\n      while (\n        nextChild != null &&\n        (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))\n      ) {\n        // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n        // been applied to the limited filter yet. Ignore this next child which will be updated later in\n        // the limited filter...\n        nextChild = source.getChildAfterChild(\n          this.index_,\n          nextChild,\n          this.reverse_\n        );\n      }\n      const compareNext =\n        nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n      const remainsInWindow =\n        inRange && !childSnap.isEmpty() && compareNext >= 0;\n      if (remainsInWindow) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childChangedChange(childKey, childSnap, oldChildSnap)\n          );\n        }\n        return oldEventCache.updateImmediateChild(childKey, childSnap);\n      } else {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(childKey, oldChildSnap)\n          );\n        }\n        const newEventCache = oldEventCache.updateImmediateChild(\n          childKey,\n          ChildrenNode.EMPTY_NODE\n        );\n        const nextChildInRange =\n          nextChild != null && this.rangedFilter_.matches(nextChild);\n        if (nextChildInRange) {\n          if (changeAccumulator != null) {\n            changeAccumulator.trackChildChange(\n              Change.childAddedChange(nextChild.name, nextChild.node)\n            );\n          }\n          return newEventCache.updateImmediateChild(\n            nextChild.name,\n            nextChild.node\n          );\n        } else {\n          return newEventCache;\n        }\n      }\n    } else if (childSnap.isEmpty()) {\n      // we're deleting a node, but it was not in the window, so ignore it\n      return snap;\n    } else if (inRange) {\n      if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(windowBoundary.name, windowBoundary.node)\n          );\n          changeAccumulator.trackChildChange(\n            Change.childAddedChange(childKey, childSnap)\n          );\n        }\n        return oldEventCache\n          .updateImmediateChild(childKey, childSnap)\n          .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n      } else {\n        return snap;\n      }\n    } else {\n      return snap;\n    }\n  }\n}\n"]}